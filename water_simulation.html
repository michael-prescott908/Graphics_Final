<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Computer Graphics - Final Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #11111111;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				text-align:center;
			}
		</style>

	</head>

	<body>
		<script src="./three.js-dev/three.js-dev/build/three.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/WebGL.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/libs/stats.min.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/libs/dat.gui.min.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/controls/OrbitControls.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/loaders/OBJLoader.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/SimplexNoise.js"></script>
		<script src="./three.js-dev/three.js-dev/examples/js/GPUComputationRenderer.js"></script>

		<script id="heightmapFragmentShader" type="x-shader/x-fragment">
			#include <common>
			uniform float viscosityConstant;
			uniform float heightCompensation;
			void main()	{
				vec2 cellSize = 1.0 / resolution.xy;
				vec2 uv = gl_FragCoord.xy * cellSize;
				vec4 heightmapValue = texture2D( heightmap, uv );

				vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
				vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
				vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
				vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

				float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosityConstant;
				heightmapValue.y = heightmapValue.x;
				heightmapValue.x = newHeight;
				gl_FragColor = heightmapValue;
			}
		</script>

		<script id="smoothFragmentShader" type="x-shader/x-fragment">
			uniform sampler2D texture;
			void main()	{
				vec2 cellSize = 1.0 / resolution.xy;
				vec2 uv = gl_FragCoord.xy * cellSize;

				vec4 textureValue = texture2D( texture, uv );
				textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
				textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
				textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
				textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );
				textureValue /= 5.0;
				gl_FragColor = textureValue;
			}
		</script>

		<script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">
			uniform vec2 point1;
			uniform sampler2D texture;
			float shift_right( float v, float amt ) {
				v = floor( v ) + 0.5;
				return floor( v / exp2( amt ) );
			}
			float shift_left( float v, float amt ) {
				return floor( v * exp2( amt ) + 0.5 );
			}
			float mask_last( float v, float bits ) {
				return mod( v, shift_left( 1.0, bits ) );
			}
			float extract_bits( float num, float from, float to ) {
				from = floor( from + 0.5 ); to = floor( to + 0.5 );
				return mask_last( shift_right( num, from ), to - from );
			}
			vec4 encode_float( float val ) {
				if ( val == 0.0 ) return vec4( 0, 0, 0, 0 );
				float sign = val > 0.0 ? 0.0 : 1.0;
				val = abs( val );
				float exponent = floor( log2( val ) );
				float biased_exponent = exponent + 127.0;
				float fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;
				float t = biased_exponent / 2.0;
				float last_bit_of_biased_exponent = fract( t ) * 2.0;
				float remaining_bits_of_biased_exponent = floor( t );
				float byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;
				float byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;
				float byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
				float byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
				return vec4( byte4, byte3, byte2, byte1 );
			}
			void main()	{
				vec2 cellSize = 1.0 / resolution.xy;
				float waterLevel = texture2D( texture, point1 ).x;
				vec2 normal = vec2(
					( texture2D( texture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( texture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( texture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( texture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );
				if ( gl_FragCoord.x < 1.5 ) {
					gl_FragColor = encode_float( waterLevel );
				} else if ( gl_FragCoord.x < 2.5 ) {
					gl_FragColor = encode_float( normal.x );
				} else if ( gl_FragCoord.x < 3.5 ) {
					gl_FragColor = encode_float( normal.y );
				} else {
					gl_FragColor = encode_float( 0.0 );
				}
			}
		</script>

		<script id="waterVertexShader" type="x-shader/x-vertex">
			uniform sampler2D heightmap;
			#define PHONG
			varying vec3 vViewPosition;
			#ifndef FLAT_SHADED
				varying vec3 vNormal;
			#endif
			#include <common>
			#include <uv_pars_vertex>
			#include <uv2_pars_vertex>
			#include <displacementmap_pars_vertex>
			#include <envmap_pars_vertex>
			#include <color_pars_vertex>
			#include <morphtarget_pars_vertex>
			#include <skinning_pars_vertex>
			#include <shadowmap_pars_vertex>
			#include <logdepthbuf_pars_vertex>
			#include <clipping_planes_pars_vertex>
			void main() {
				vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );
				#include <uv_vertex>
				#include <uv2_vertex>
				#include <color_vertex>

				vec3 objectNormal = vec3(
					( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
					1.0 );
				#include <morphnormal_vertex>
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#include <defaultnormal_vertex>
			#ifndef FLAT_SHADED
				vNormal = normalize( transformedNormal );
			#endif
				float heightValue = texture2D( heightmap, uv ).x;
				vec3 transformed = vec3( position.x, position.y, heightValue );
				#include <morphtarget_vertex>
				#include <skinning_vertex>
				#include <displacementmap_vertex>
				#include <project_vertex>
				#include <logdepthbuf_vertex>
				#include <clipping_planes_vertex>
				vViewPosition = - mvPosition.xyz;
				#include <worldpos_vertex>
				#include <envmap_vertex>
				#include <shadowmap_vertex>
			}
		</script>

		<script>
			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			}
			var hash = document.location.hash.substr( 1 );
			if ( hash ) hash = parseInt( hash, 0 );

			var WIDTH = hash || 128;
			var BOUNDS = 512;
			var BOUNDS_HALF = BOUNDS * 0.5;
			var container, stats;
			var fish1 = new THREE.Object3D();
			var fish2 = new THREE.Object3D();
			var fish3 = new THREE.Object3D();
			var fish4 = new THREE.Object3D();
			var fish5 = new THREE.Object3D();
			var fish6 = new THREE.Object3D();
			var camera, scene, renderer;
			var mouseMoved = false;
			var mouseCoords = new THREE.Vector2();
			var raycaster = new THREE.Raycaster();
			var waterMesh;
			var meshRay;
			var gpuCompute;
			var heightmapVariable;
			var waterUniforms;
			var smoothShader;
			var readWaterLevelShader;
			var readWaterLevelRenderTarget;
			var readWaterLevelImage;
			var waterNormal = new THREE.Vector3();
			var NUM_SHAPES = 5;
			var shapes = [];
			var simplex = new SimplexNoise();
			var fishx = -500, fishy = -100, fishz = 0;

			var particleCount = 1800,
			particles = new THREE.Geometry(),
			pMaterial = new THREE.ParticleBasicMaterial({
			color: 0x000088,
			size: 20,
			map: new THREE.TextureLoader().load(
				"https://i.imgur.com/ROZaUXl.png"),
			blending: THREE.AdditiveBlending,
			transparent: true
			});
			var particleSystem;
			var particlePosition = 50;
			var doneWLoop = false;
			init();
			animate();
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.set( -88, 31, 392 );
				scene = new THREE.Scene();

                var sun = new THREE.DirectionalLight( 0xFFFFFF, 1.0 );
				sun.position.set( 300, 400, 175 );
				scene.add( sun );

                var geometry = new THREE.CubeGeometry(1000, 1000, 1000);
                var cubeMaterials = [
					new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("https://i.imgur.com/0wIwqOG.jpg"), side: THREE.DoubleSide}),
					new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("https://i.imgur.com/4CZdaLV.jpg"), side: THREE.DoubleSide}),
					new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("https://i.imgur.com/1F5Lf1U.jpg"), side: THREE.DoubleSide}),
					new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("https://i.imgur.com/mrZlV56.png"), side: THREE.DoubleSide}),
					new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("https://i.imgur.com/YSeGuV0.jpg"), side: THREE.DoubleSide}),
					new THREE.MeshBasicMaterial({map: new THREE.TextureLoader().load("https://i.imgur.com/p0lvUcr.jpg"), side: THREE.DoubleSide}),
                ];

                var cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterials);
                var cube = new THREE.Mesh(geometry, cubeMaterial);
                scene.add(cube);

				//Fish 1
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/fishOBJ.obj',
					function(object){
						object.rotateZ(-45);
						object.translateY(-100);
						//object.translateX(fishx);
						object.scale.set(3, 3, 3);
						fish1 = object;
						console.log(object);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Fish 2
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/fishOBJ.obj',
					function(object){
						object.rotateZ(-45);
						object.translateY(-150);
						//object.translateX(fishx);
						object.scale.set(3, 3, 3);
						fish2 = object;
						console.log(object);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Fish 3
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/fishOBJ.obj',
					function(object){
						object.rotateZ(-45);
						object.rotateY(0);
						object.translateY(-175);
						//object.translateX(fishx);
						object.scale.set(3, 3, 3);
						fish3 = object;
						console.log(object);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Fish 4
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/fishOBJ.obj',
					function(object){
						object.rotateZ(-45);
						object.rotateY(0);
						object.translateY(-175);
						//object.translateX(fishx);
						object.scale.set(3, 3, 3);
						fish4 = object;
						console.log(object);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Fish 5
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/fishOBJ.obj',
					function(object){
						object.rotateZ(-45);
						object.rotateY(0);
						object.translateY(-160);
						//object.translateX(fishx);
						object.scale.set(3, 3, 3);
						fish5 = object;
						console.log(object);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Fish 6
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/fishOBJ.obj',
					function(object){
						object.rotateZ(-45);
						object.rotateY(0);
						object.translateY(-190);
						//object.translateX(fishx);
						object.scale.set(3, 3, 3);
						fish6 = object;
						console.log(object);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Plant 1
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/berberys_orange.obj',
					function(object){
						//object.rotateZ(-45);
						//object.rotateY(0);
						object.translateY(-500);
						object.translateX(200);
						object.translateZ(200);
						//object.translateX(fishx);
						object.scale.set(.2, .2, .2);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Plant 2
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/berberys_orange.obj',
					function(object){
						//object.rotateZ(-45);
						//object.rotateY(0);
						object.translateY(-500);
						object.translateX(-200);
						object.translateZ(-200);
						//object.translateX(fishx);
						object.scale.set(.2, .2, .2);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				//Plant 3
				var loader = new THREE.OBJLoader();
				var tempObj;
				loader.load(
					'https://raw.githubusercontent.com/michael-prescott908/Graphics_Files/master/berberys_orange.obj',
					function(object){
						//object.rotateZ(-45);
						//object.rotateY(0);
						object.translateY(-500);
						object.translateX(200);
						object.translateZ(-200);
						//object.translateX(fishx);
						object.scale.set(.2, .2, .2);
						scene.add(object);
					},
					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				)

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				var controls = new THREE.OrbitControls( camera, renderer.domElement );
				stats = new Stats();

				initWater();
				createSpheres();
				createAnvils();
				createMiddles();
			}

			function initWater() {
				var materialColor = 0x0040C0;
				var geometry = new THREE.PlaneBufferGeometry( 1000, 1000, WIDTH - 1, WIDTH - 1 );

				var material = new THREE.ShaderMaterial( {
					uniforms: THREE.UniformsUtils.merge( [
						THREE.ShaderLib[ 'phong' ].uniforms,
						{
							heightmap: { value: null }
						}
					] ),
					vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
					fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]
				} );
				material.lights = true;
				material.color = new THREE.Color( materialColor );
				material.specular = new THREE.Color( 0x111111 );
				material.shininess = 50;
				material.transparent = true;
				material.opacity = .5;
				material.uniforms.diffuse.value = material.color;
				material.uniforms.specular.value = material.specular;
				material.uniforms.shininess.value = Math.max( material.shininess, 1e-4 );
				material.uniforms.opacity.value = material.opacity;

				material.defines.WIDTH = WIDTH.toFixed( 1 );
				material.defines.BOUNDS = BOUNDS.toFixed( 1 );
				waterUniforms = material.uniforms;
				waterMesh = new THREE.Mesh( geometry, material );
				waterMesh.rotation.x = - Math.PI / 2;
				waterMesh.matrixAutoUpdate = false;
				waterMesh.updateMatrix();
				scene.add( waterMesh );


				var geometryRay = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, 1, 1 );
				meshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );
				meshRay.rotation.x = - Math.PI / 2;
				meshRay.matrixAutoUpdate = false;
				meshRay.updateMatrix();
				scene.add( meshRay );
				var geometry = new THREE.BoxGeometry( 999, 425, 999 );
				var material = new THREE.MeshBasicMaterial( {color: 0x000066, side: THREE.DoubleSide } );
				material.transparent = true;
				material.opacity = .8;
				geometry.translate(0, -250, 0);
				var cube = new THREE.Mesh( geometry, material );
				scene.add( cube );

				// now create the individual particles
				for (var p = 0; p < particleCount; p++) {

  			// create a particle with random
  			// position values, -250 -> 250
  			var pX = Math.random() * 1000 - 500,
      	pY = Math.random() * 500 - 500,
      	pZ = Math.random() * 1000 - 500,
      	particle = new THREE.Vector3(pX, pY, pZ);
				particle.velocity = new THREE.Vector3(
  			0,              // x
  			Math.random(), // y: random vel
  			0);
  			// add it to the geometry
  			particles.vertices.push(particle);
				}

				// create the particle system
				particleSystem = new THREE.Points(
    			particles,
    			pMaterial);
				particleSystem.sortParticles = true;

				// add it to the scene
				scene.add(particleSystem);

				gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );
				var heightmap0 = gpuCompute.createTexture();
				fillTexture( heightmap0 );
				heightmapVariable = gpuCompute.addVariable( "heightmap", document.getElementById( 'heightmapFragmentShader' ).textContent, heightmap0 );
				gpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );

				heightmapVariable.material.uniforms.mouseSize = { value: 100.0 };
				heightmapVariable.material.uniforms.viscosityConstant = { value: 0.999 };
				heightmapVariable.material.uniforms.heightCompensation = { value: 0 };
				heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );
				var error = gpuCompute.init();
				if ( error !== null ) {
				    console.error( error );
				}

				smoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { texture: { value: null } } );
				readWaterLevelShader = gpuCompute.createShaderMaterial( document.getElementById( 'readWaterLevelFragmentShader' ).textContent, {
					point1: { value: new THREE.Vector2() },
					texture: { value: null }
				} );
				readWaterLevelShader.defines.WIDTH = WIDTH.toFixed( 1 );
				readWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed( 1 );

				readWaterLevelImage = new Uint8Array( 4 * 1 * 4 );
				readWaterLevelRenderTarget = new THREE.WebGLRenderTarget( 4, 1, {
					wrapS: THREE.ClampToEdgeWrapping,
					wrapT: THREE.ClampToEdgeWrapping,
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.UnsignedByteType,
					stencilBuffer: false,
					depthBuffer: false
				} );
			}

			function fillTexture( texture ) {
				var waterMaxHeight = 10;
				function noise( x, y ) {
					var multR = waterMaxHeight;
					var mult = 0.025;
					var r = 0;
					for ( var i = 0; i < 15; i ++ ) {
						r += multR * simplex.noise( x * mult, y * mult );
						multR *= 0.53 + 0.025 * i;
						mult *= 1.25;
					}
					return r;
				}
				var pixels = texture.image.data;
				var p = 0;
				for ( var j = 0; j < WIDTH; j ++ ) {
					for ( var i = 0; i < WIDTH; i ++ ) {
						var x = i * 128 / WIDTH;
						var y = j * 128 / WIDTH;
						pixels[ p + 0 ] = noise( x, y, 123.4 );
						pixels[ p + 1 ] = pixels[ p + 0 ];
						pixels[ p + 2 ] = 0;
						pixels[ p + 3 ] = 1;
						p += 4;
					}
				}
			}

			function createSpheres() {
				var sphereTemplate = new THREE.Mesh( new THREE.BoxGeometry( 10, 10, 10 ), new THREE.MeshPhongMaterial( {  map: new THREE.TextureLoader().load("https://i.imgur.com/IPcmVFn.jpg") } ) );
				for ( var i = 0; i < NUM_SHAPES; i ++ ) {
					var sphere = sphereTemplate;
					if ( i < NUM_SHAPES - 1 ) {
						sphere = sphereTemplate.clone();
				}
					sphere.position.x = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					sphere.position.z = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					sphere.userData.velocity = new THREE.Vector3();
					sphere.overdraw = true;
					scene.add( sphere );
					shapes[ i ] = sphere;
				}
			}

			function sphereDynamics() {
				var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
				readWaterLevelShader.uniforms.texture.value = currentRenderTarget.texture;
				var gl = renderer.context;
				for ( var i = 0; i < NUM_SHAPES; i ++ ) {
					var sphere = shapes[ i ];
					if ( sphere ) {

						var u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;
						var v = 1 - ( 0.5 * sphere.position.z / BOUNDS_HALF + 0.5 );
						readWaterLevelShader.uniforms.point1.value.set( u, v );
						gpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );
						gl.readPixels( 0, 0, 4, 1, gl.RGBA, gl.UNSIGNED_BYTE, readWaterLevelImage );
						var pixels = new Float32Array( readWaterLevelImage.buffer );

						waterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );
						var pos = sphere.position;
						pos.y = pixels[ 0 ];

						waterNormal.multiplyScalar( 0.1 );
						sphere.userData.velocity.add( waterNormal );
						sphere.userData.velocity.multiplyScalar( 0.998 );
						pos.add( sphere.userData.velocity );
						if ( pos.x < - BOUNDS_HALF ) {
							pos.x = - BOUNDS_HALF + 0.001;
							sphere.userData.velocity.x *= - 0.3;
						} else if ( pos.x > BOUNDS_HALF ) {
							pos.x = BOUNDS_HALF - 0.001;
							sphere.userData.velocity.x *= - 0.3;
						}
						if ( pos.z < - BOUNDS_HALF ) {
							pos.z = - BOUNDS_HALF + 0.001;
							sphere.userData.velocity.z *= - 0.3;
						} else if ( pos.z > BOUNDS_HALF ) {
							pos.z = BOUNDS_HALF - 0.001;
							sphere.userData.velocity.z *= - 0.3;
						}
					}
				}
			}

			function createAnvils() {
				var anvilTemplate = new THREE.Mesh( new THREE.CylinderGeometry( 20, 20, 20, 32 ), new THREE.MeshPhongMaterial( { map: new THREE.TextureLoader().load("https://i.imgur.com/qKOuSyp.jpg") } ) );
				for ( var i = 0; i < NUM_SHAPES; i ++ ) {
					var anvil = anvilTemplate;
					if ( i < NUM_SHAPES - 1 ) {
						anvil = anvilTemplate.clone();
				}
					anvil.position.x = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					anvil.position.z = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					anvil.userData.velocity = new THREE.Vector3();
					anvil.overdraw = true;
					scene.add( anvil );
					shapes[ i + 5 ] = anvil;
				}
			}

			function anvilDynamics() {
				var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
				readWaterLevelShader.uniforms.texture.value = currentRenderTarget.texture;
				var gl = renderer.context;
				for ( var i = 0; i < NUM_SHAPES; i ++ ) {
					var anvil = shapes[ i + 5];
					if ( anvil ) {

						var u = 0.5 * anvil.position.x / BOUNDS_HALF + 0.5;
						var v = 1 - ( 0.5 * anvil.position.z / BOUNDS_HALF + 0.5 );
						readWaterLevelShader.uniforms.point1.value.set( u, v );
						gpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );
						gl.readPixels( 0, 0, 4, 1, gl.RGBA, gl.UNSIGNED_BYTE, readWaterLevelImage );
						var pixels = new Float32Array( readWaterLevelImage.buffer );
						waterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );
						var pos = anvil.position;

						pos.y = Math.max(pixels[ 0 ] - 500, -500);
						waterNormal.multiplyScalar( 0.1 );
						anvil.userData.velocity.add( waterNormal );
						anvil.userData.velocity.multiplyScalar( 0.998 );
						pos.add( anvil.userData.velocity );
						if ( pos.x < - BOUNDS_HALF ) {
							pos.x = - BOUNDS_HALF + 0.001;
							anvil.userData.velocity.x *= - 0.3;
						} else if ( pos.x > BOUNDS_HALF ) {
							pos.x = BOUNDS_HALF - 0.001;
							anvil.userData.velocity.x *= - 0.3;
						}
						if ( pos.z < - BOUNDS_HALF ) {
							pos.z = - BOUNDS_HALF + 0.001;
							anvil.userData.velocity.z *= - 0.3;
						} else if ( pos.z > BOUNDS_HALF ) {
							pos.z = BOUNDS_HALF - 0.001;
							anvil.userData.velocity.z *= - 0.3;
						}
					}
				}
			}

			function createMiddles() {
				var sphereTemplate = new THREE.Mesh( new THREE.SphereBufferGeometry( 12, 24, 12 ), new THREE.MeshPhongMaterial( {  map: new THREE.TextureLoader().load("https://i.imgur.com/vyBRIoA.jpg", THREE.SphericalRefractionMapping) } ) );
				for ( var i = 0; i < NUM_SHAPES; i ++ ) {
					var sphere = sphereTemplate;
					if ( i < NUM_SHAPES - 1 ) {
						sphere = sphereTemplate.clone();
				}
					sphere.position.x = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					sphere.position.z = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					sphere.userData.velocity = new THREE.Vector3();
					sphere.overdraw = true;
					scene.add( sphere );
					shapes[ i + 10 ] = sphere;
				}
			}

			function middleDynamics() {
				var currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );
				readWaterLevelShader.uniforms.texture.value = currentRenderTarget.texture;
				var gl = renderer.context;
				for ( var i = 0; i < NUM_SHAPES; i ++ ) {
					var sphere = shapes[ i + 10 ];
					if ( sphere ) {

						var u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;
						var v = 1 - ( 0.5 * sphere.position.z / BOUNDS_HALF + 0.5 );
						readWaterLevelShader.uniforms.point1.value.set( u, v );
						gpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );
						gl.readPixels( 0, 0, 4, 1, gl.RGBA, gl.UNSIGNED_BYTE, readWaterLevelImage );
						var pixels = new Float32Array( readWaterLevelImage.buffer );
						waterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );
						var pos = sphere.position;

						pos.y = pixels[ 0 ] - 250;
						waterNormal.multiplyScalar( 0.1 );
						sphere.userData.velocity.add( waterNormal );
						sphere.userData.velocity.multiplyScalar( 0.998 );
						pos.add( sphere.userData.velocity );
						if ( pos.x < - BOUNDS_HALF ) {
							pos.x = - BOUNDS_HALF + 0.001;
							sphere.userData.velocity.x *= - 0.3;
						} else if ( pos.x > BOUNDS_HALF ) {
							pos.x = BOUNDS_HALF - 0.001;
							sphere.userData.velocity.x *= - 0.3;
						}
						if ( pos.z < - BOUNDS_HALF ) {
							pos.z = - BOUNDS_HALF + 0.001;
							sphere.userData.velocity.z *= - 0.3;
						} else if ( pos.z > BOUNDS_HALF ) {
							pos.z = BOUNDS_HALF - 0.001;
							sphere.userData.velocity.z *= - 0.3;
						}
					}
				}
			}

			function animate() {
				particleSystem.rotation.y += 0.01;
				requestAnimationFrame( animate );
				render();
				stats.update();
			}

			function moveFish() {
				fishx += 1;
				fishz += 1;

				if(fishx === 500){
					fishx = -500;
				}

				if(fishz === 500){
					fishz = -500;
				}

				fish1.position.setX(fishx);
				fish2.position.setX(fishx/.5);
				fish3.position.setX(fishx/.5);
				fish3.position.setZ(fishz);
				fish4.position.setX(fishx/.2);
				fish4.position.setZ(fishz/.6);
				fish5.position.setX(fishx/.3);
				fish5.position.setZ(fishz/.5);
				fish6.position.setX(fishx/.4);
				fish6.position.setZ(fishz/.2);
			}

			function render() {
				gpuCompute.compute();
				sphereDynamics();
				anvilDynamics();
				middleDynamics();
				moveFish();
				waterUniforms.heightmap.value = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
